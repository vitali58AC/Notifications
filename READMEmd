# Оповещения


Что нужно сделать
~~~ 1. Создайте два канала для оповещений. Один для приоритетных сообщений,
 другой — для неприоритетных.
 Создавайте каналы перед любым возможным отображением оповещения, например,
  в Application.onCreate.

~~~ 2. Приоритетные сообщения должны по умолчанию отображаться как всплывающие, со звуком.
Неприоритетные появляются без звука в шторке уведомлений.

~~~ 3. Создайте Firebase-проект на сайте http://console.firebase.google.com/.

~~~ 4. Добавьте в проект приложение.

~~~ 5. Подключите Firebase-зависимости для FCM в приложение.
https://firebase.google.com/docs/cloud-messaging/android/client

~~~ 6. Добавьте сервис получения оповещений и обновления токена. Наследуйте сервис от
FirebaseMessagingService.

~~~ 7. Реализуйте получение Firebase-токена при открытии главного экрана.

~~~ 8. Отправьте по полученному токену сообщение с помощью POST-запроса.

Пример запроса с помощью curl можно найти в CodeSample в файле send_message.sh.

Как установить curl на windows:
https://starkovden.github.io/curl-intro-and-instalation.html#curl-%D0%B8-windows.

Вместо curl вы можете использовать ретрофит, но лучше для этого подойдёт другое приложение,
чтобы можно было отправлять сообщения, когда принимающее приложение закрыто.

~~~ 9. Используйте data-сообщения.

~~~ 10. Научитесь отправлять и принимать два вида сообщений:

    ~~~ сообщения о новых акциях. Они должны иметь: title: String, description: String,
        imageUrl: String?.
        Сообщения должны отображаться с помощью неприоритетных оповещений, в которых есть
        title, description, small icon, large icon (изображение по imageUrl, если он не null).

    ~~~ сообщения из чата. Они должны иметь: userId: Long, userName: String,
        created_at: Long (timestamp), text: String.
        Сообщения должны отображаться с помощью приоритетных оповещений, в которых есть
         title (userName), description(text), small icon.
        Сообщения от одного пользователя должны обновлять оповещения друг друга, а не
        генерировать новые.

~~~ 11. При открытии приложения не через оповещение все созданные оповещения должны исчезать.
Для этого используйте метод NotificationManager.cancelAll.

~~~ 12. По нажатии на оповещение должно открываться приложение.

~~~ 13. Добавьте в приложение экран синхронизации. На нём должна быть кнопка синхронизации.

~~~ 14. На экране синхронизации подпишитесь на изменение состояния сети с помощью BroadcastReceiver.
https://developer.android.com/training/basics/network-ops/managing

~~~ 15. Если при нажатии на кнопку синхронизации нет сети, должен выводиться тост о необходимости
подключиться к интернету.

~~~ 16. Если сеть есть, должно отображаться оповещение синхронизации с прогрессом, кнопка
синхронизации при этом становится неактивной, прогресс заполняется постепенно, происходит имитация
синхронизации. После полного заполнения прогресса оповещение прогресса меняется на «синхронизация
 завершена», и через секунду пропадает.

~~~ 17. По желанию добавьте переход на конкретный экран в приложении по нажатии на оповещение.
 Например, на экран чата с пользователем. На экране чата с пользователем должны отображаться
 сообщения из БД. Сообщения сохраняются в БД в тот момент, когда приходит событие от FCM.

>>> 18. По желанию добавьте возможность Reply to action для оповещения о сообщении:
 https://developer.android.com/training/notify-user/build-notification#reply-action

~~~ 19. По желанию в функционал синхронизации добавьте скачивание файла, прогресс оповещения должен
обновляться в соответствии с прогрессом скачивания файла. Пример для Okhttp:
https://github.com/square/okhttp/blob/master/samples/guide/src/main/java/okhttp3/recipes/Progress.java



Рекомендации по выполнению
1. Small icon для оповещения должна быть одноцветной и иметь прозрачный background, иначе она
будет выглядеть полностью залитой областью в статус-баре и в оповещении.

2. При отправке сообщений из fcm полезные данные легче всего отправлять в формате JSON, и в
 отдельном поле отправлять тип данных.

Например:

{
    ...
    "data":{
        "type":"message",
        "data":{
            "user":"ivan",
            "text":"Hi"
        }
    }
    ...
}
Посмотрев на type: message, можно понять, что в поле data будет находиться json, который описывает
сообщение. И десериализовать его в объект сообщения, например, с помощью Moshi.
Если приходит fcm-сообщение с type=news, то нужно десериализовать модель новости.



Критерии оценки
1. Оповещения должны отображаться на устройствах с любыми версиями ОС >=Android 5.0.

2. Оповещения для FCM-сообщений должны одинаково отображаться вне зависимости от состояния
 приложения (открыто, свёрнуто, закрыто).

3. Для каждого из вида оповещений должны использоваться свои каналы.

4. Оповещения должны обновлять предыдущие оповещения, если они относятся к одному событию,
требующему определённого действия (сообщение от одного пользователя).

5. Оповещения скрываются по нажатии на них.

6. Используется Context-registered broadcast receiver.

7. Выполнены все пункты в соответствии с заданием.



Как отправить задание на проверку
Используйте репозиторий android_basics.
Скачайте изменения в репозитории на локальную машину.
Выполните домашнее задание в папке Notifications.
Отправьте коммиты в удалённый репозиторий.